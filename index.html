
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Introduction Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-page-toc/page-toc.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="docs/ssq.html" />
    
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter active" data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="docs/ssq.html">
            
                <a href="docs/ssq.html">
            
                    
                    ssq
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="docs/ssq_Array.html">
            
                <a href="docs/ssq_Array.html">
            
                    
                    Array
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="docs/ssq_Class.html">
            
                <a href="docs/ssq_Class.html">
            
                    
                    Class
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.2.1" data-path="docs/ssq_Class_Ctor.html">
            
                <a href="docs/ssq_Class_Ctor.html">
            
                    
                    Ctor
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.2" data-path="docs/ssq_Class_Ctor__T_Args_____.html">
            
                <a href="docs/ssq_Class_Ctor__T_Args_____.html">
            
                    
                    Ctor< T(Args...)>
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="docs/ssq_CompileException.html">
            
                <a href="docs/ssq_CompileException.html">
            
                    
                    CompileException
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="docs/ssq_Enum.html">
            
                <a href="docs/ssq_Enum.html">
            
                    
                    Enum
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="docs/ssq_Exception.html">
            
                <a href="docs/ssq_Exception.html">
            
                    
                    Exception
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="docs/ssq_Function.html">
            
                <a href="docs/ssq_Function.html">
            
                    
                    Function
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="docs/ssq_Instance.html">
            
                <a href="docs/ssq_Instance.html">
            
                    
                    Instance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="docs/ssq_Libs.html">
            
                <a href="docs/ssq_Libs.html">
            
                    
                    Libs
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="docs/ssq_NotFoundException.html">
            
                <a href="docs/ssq_NotFoundException.html">
            
                    
                    NotFoundException
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="docs/ssq_Object.html">
            
                <a href="docs/ssq_Object.html">
            
                    
                    Object
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.11" data-path="docs/ssq_RuntimeException.html">
            
                <a href="docs/ssq_RuntimeException.html">
            
                    
                    RuntimeException
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.12" data-path="docs/ssq_Script.html">
            
                <a href="docs/ssq_Script.html">
            
                    
                    Script
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.13" data-path="docs/ssq_SqWeakRef.html">
            
                <a href="docs/ssq_SqWeakRef.html">
            
                    
                    SqWeakRef
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.14" data-path="docs/ssq_Table.html">
            
                <a href="docs/ssq_Table.html">
            
                    
                    Table
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.15" data-path="docs/ssq_TypeException.html">
            
                <a href="docs/ssq_TypeException.html">
            
                    
                    TypeException
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.16" data-path="docs/ssq_VM.html">
            
                <a href="docs/ssq_VM.html">
            
                    
                    VM
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Introduction</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="simplesquirrel">SimpleSquirrel</h1>
<p>Yet another simple binding in C++11 for <a href="http://www.squirrel-lang.org/" target="_blank">Squirrel scripting language</a></p>
<p>API Documentation can be found here: <a href="https://matusnovak.github.io/simplesquirrel/docs/ssq.html" target="_blank">https://matusnovak.github.io/simplesquirrel/docs/ssq.html</a></p>
<h2 id="features">Features</h2>
<ul>
<li>MIT licensed</li>
<li>32 and 64 bit support</li>
<li>C++11</li>
<li>Supports multiple virtual machines</li>
<li>Supports lambdas</li>
<li>Very easy object manipulation</li>
<li>Supports binding of C++ classes to multiple instances of Squirrel VM</li>
<li>Strict type checking on C++ side</li>
<li>wchar_t support, a.k.a Squirrel Unicode (experimental!) - I highly recommend using UTF8 as chars and not UNICODE as wchar_t</li>
<li>Works with Visual Studio 2015, Visual Studio 2017, MinGW-w64, Linux GCC, and OSX Clang </li>
<li>Allows the following:<ul>
<li>Binding C++ function and calling it from Squirrel</li>
<li>Looking up Squirrel function and calling it from C++</li>
<li>Looking up Squirrel classes and creating instances on C++ side</li>
<li>Binding C++ classes including methods and member variables</li>
<li>Passing any C++ pointer as either instance or userpointer (depends if your C++ has been exposed to VM)</li>
<li>Creating enumerations</li>
<li>Creating and passing tables</li>
<li>Creating and passing arrays</li>
</ul>
</li>
<li><strong>The following is not yet implemented:</strong><ul>
<li>Method overloading</li>
<li>Derivate Squirrel class</li>
<li><strong>Thread safety</strong></li>
</ul>
</li>
</ul>
<h2 id="install-squirrel">Install Squirrel</h2>
<p>First, download and build Squirrel library using cmake. Use the command line instructions below.
By default the <code>CMAKE_INSTALL_PREFIX</code> will point to <code>C:/Program Files/squirrel</code> on Windows or
<code>/home/username/squirrel</code> on Linux.</p>
<p><strong>Linux:</strong></p>
<pre><code class="lang-bash">git <span class="hljs-built_in">clone</span> https://github.com/albertodemichelis/squirrel.git
<span class="hljs-built_in">cd</span> squirrel
mkdir build
<span class="hljs-built_in">cd</span> build
cmake .. -DCMAKE_INSTALL_PREFIX=/usr/<span class="hljs-built_in">local</span> -DCMAKE_C_FLAGS=<span class="hljs-string">&quot;-fPIC&quot;</span>

<span class="hljs-comment"># Build and install into the install prefix folder</span>
sudo make install

<span class="hljs-comment"># Copy header files (This is missing from cmake instructions in squirrel library)</span>
sudo cp -rfv ../include* /usr/<span class="hljs-built_in">local</span>/include
find . -name <span class="hljs-string">&quot;/usr/local/include/sq*.h&quot;</span> -exec chmod 644 {} \;
</code></pre>
<p><strong>Windows:</strong></p>
<pre><code class="lang-bash">git <span class="hljs-built_in">clone</span> https://github.com/albertodemichelis/squirrel.git
<span class="hljs-built_in">cd</span> squirrel
mkdir build
<span class="hljs-built_in">cd</span> build
cmake .. -DCMAKE_INSTALL_PREFIX=C:/whatever/folder/you/want
make install
</code></pre>
<h2 id="install-simplqsquirrel">Install SimplqSquirrel</h2>
<p>To compile and install Squirrel Bind use the command line instructions below. I highly recommend
using the GUI tool <code>cmake-gui</code> and set it up from there using your favourite IDE as generator.</p>
<p><strong>Linux:</strong></p>
<pre><code class="lang-bash">git <span class="hljs-built_in">clone</span> https://github.com/matusnovak/simplesquirrel.git
<span class="hljs-built_in">cd</span> simplesquirrel
mkdir build
<span class="hljs-built_in">cd</span> build
cmake .. -DCMAKE_INSTALL_PREFIX=/usr/<span class="hljs-built_in">local</span> -DBUILD_TESTS=OFF
sudo make install
</code></pre>
<p><strong>Windows:</strong></p>
<pre><code class="lang-bash">git <span class="hljs-built_in">clone</span> https://github.com/matusnovak/simplesquirrel.git
<span class="hljs-built_in">cd</span> simplesquirrel
mkdir build
<span class="hljs-built_in">cd</span> build
cmake .. -G <span class="hljs-string">&quot;Visual Studio 15 2017&quot;</span> -DCMAKE_INSTALL_PREFIX=C:/whatever/folder/you/want -DBUILD_TESTS=OFF
</code></pre>
<p>If you get errors that <code>SQSTDLIB_LIBRARIES</code> and <code>SQUIRREL_LIBRARIES</code> was not found, you need to
point it to the right direction when running cmake command. Either <strong>open GUI version of cmake</strong> and set
the <code>SQSTDLIB_LIBRARIES</code> and <code>SQUIRREL_LIBRARIES</code> so it points to the correct <code>squirrel.lib</code> and 
<code>sqstdlib.lib</code>. Don&apos;t forget to set <code>INCLUDE_DIRECTORIES</code> to Squirrel include directory! (the directory
that contains <code>squirrel.h</code> file)</p>
<p>If you prefer command line, use the following command:</p>
<pre><code>cmake .. -G &quot;Visual Studio 15 2017&quot; \
    -DCMAKE_INSTALL_PREFIX=C:/whatever/folder/you/want \
    -DINCLUDE_DIRECTORIES=C:/Users/username/Documents/squirrel/include \
    -DSQUIRREL_LIBRARIES=C:/Users/username/Documents/squirrel/build/squirrel/MinSizeRel/squirrel_static.lib \
    -DSQSTDLIB_LIBRARIES=C:/Users/username/Documents/squirrel/build/sqstdlib/MinSizeRel/sqstdlib_static.lib \
    -DBUILD_TESTS=OFF
</code></pre><h2 id="create-squirrel-vm">Create Squirrel VM</h2>
<p>Creating VM is done via its constructor. The VM will be destroyed
once it falls out of scope. Or, if you have created it via <code>new</code> operator,
it will be destroyed, and all of its resources, once you call <code>delete</code>.</p>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;simplesquirrel/simplesquirrel.hpp&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// Create and register Squirrel std libraries</span>
    <span class="hljs-comment">// More here: http://squirrel-lang.org/squirreldoc/stdlib/index.html</span>
    ssq::<span class="hljs-function">VM <span class="hljs-title">vm</span><span class="hljs-params">(<span class="hljs-number">1024</span>, ssq::Libs::STRING | ssq::Libs::IO | ssq::Libs::MATH)</span></span>;

    <span class="hljs-comment">// Available flags:</span>
    <span class="hljs-comment">// NONE</span>
    <span class="hljs-comment">// IO</span>
    <span class="hljs-comment">// BLOB</span>
    <span class="hljs-comment">// MATH</span>
    <span class="hljs-comment">// SYSTEM</span>
    <span class="hljs-comment">// STRING</span>
    <span class="hljs-comment">// ALL</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 id="compile-script">Compile script</h2>
<p>Compiling script can be done via raw source <code>const char*</code> or via path to source
file.</p>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;simplesquirrel/simplesquirrel.hpp&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    ssq::<span class="hljs-function">VM <span class="hljs-title">vm</span><span class="hljs-params">(<span class="hljs-number">1024</span>, ssq::Libs::ALL)</span></span>;

    ssq::Script scriptA = vm.compileSource(<span class="hljs-comment">/* raw char array here */</span>);
    ssq::Script scriptB = vm.compileFile(<span class="hljs-comment">/* path to source file */</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 id="squirrel-object-manipulation">Squirrel object manipulation</h2>
<p>All Squirrel objects are dynamic and they can hold any value, no static typing. Since C++
is statically typed, we need to check the type returned. You can do so by calling <code>ssq::Object::getType()</code> 
which returns <code>ssq::Type</code> enum. The object can be: instance, class, function (closure), integer, float,
string, boolean, userdata, userpointer, array, table, and null. You can convert the raw object to
any type using <code>ssq::Object::toXyz();</code> such as: <code>toInt()</code>, <code>toFloat()</code>, <code>toString()</code>, <code>toBool()</code>, 
<code>toTable()</code>, <code>toArray()</code>, <code>toClass()</code>, <code>toInstance()</code>, and <code>toFunction()</code>. To check if the object is
empty use <code>isEmpty()</code> method and to check if the object is null use <code>isNull()</code>. Note that object being
null is not the same as object being empty! However, it is impossible for Squirrel to use empty objects
so you will most likely never use <code>isEmpty()</code>, only <code>isNull()</code>.</p>
<p><strong>Always use std::string when calling Squirrel function or when casting the result of function
call from ssq::Object to string. Do not use const char* as those two types are different.</strong></p>
<p>Here are the C++ types and their Squirrel equivalents:</p>
<table>
<thead>
<tr>
<th>C++</th>
<th>Squirrel</th>
<th>Method to convert back</th>
</tr>
</thead>
<tbody>
<tr>
<td>signed char</td>
<td>integer</td>
<td><code>toInt()</code></td>
</tr>
<tr>
<td>unsigned char</td>
<td>integer</td>
<td><code>toInt()</code></td>
</tr>
<tr>
<td>char</td>
<td>integer</td>
<td><code>toInt()</code></td>
</tr>
<tr>
<td>short</td>
<td>integer</td>
<td><code>toInt()</code></td>
</tr>
<tr>
<td>unsigned short</td>
<td>integer</td>
<td><code>toInt()</code></td>
</tr>
<tr>
<td>int</td>
<td>integer</td>
<td><code>toInt()</code></td>
</tr>
<tr>
<td>unsigned int</td>
<td>integer</td>
<td><code>toInt()</code></td>
</tr>
<tr>
<td>long</td>
<td>integer</td>
<td><code>toInt()</code></td>
</tr>
<tr>
<td>unsigned long</td>
<td>integer</td>
<td><code>toInt()</code></td>
</tr>
<tr>
<td>long long (64-bit)</td>
<td>integer</td>
<td><code>toInt()</code></td>
</tr>
<tr>
<td>long long (32-bit)</td>
<td>userdata</td>
<td><code>to&lt;long long&gt;()</code></td>
</tr>
<tr>
<td>unsigned long long (64-bit)</td>
<td>integer</td>
<td><code>toInt()</code></td>
</tr>
<tr>
<td>unsigned long long (64-bit)</td>
<td>userdata</td>
<td><code>to&lt;unsigned long long&gt;()</code></td>
</tr>
<tr>
<td>std::string</td>
<td>string</td>
<td><code>toString()</code></td>
</tr>
<tr>
<td>float</td>
<td>float</td>
<td><code>toFloat()</code></td>
</tr>
<tr>
<td>double</td>
<td>float</td>
<td><code>toFloat()</code></td>
</tr>
<tr>
<td>const char*</td>
<td>userpointer</td>
<td><code>to&lt;const char*&gt;()</code></td>
</tr>
<tr>
<td>const char[N]</td>
<td>N/A</td>
<td>compiler error</td>
</tr>
<tr>
<td>char*</td>
<td>userpointer</td>
<td><code>to&lt;char*&gt;()</code></td>
</tr>
<tr>
<td>ssq::Object</td>
<td>anything</td>
<td>You can&apos;t convet ssq::Object to ssq::Object :D</td>
</tr>
<tr>
<td>ssq::Function</td>
<td>closure/nativeclosure</td>
<td><code>toFunction()</code></td>
</tr>
<tr>
<td>ssq::Class</td>
<td>class</td>
<td><code>toClass()</code></td>
</tr>
<tr>
<td>ssq::Instance</td>
<td>instance</td>
<td><code>toInstance()</code></td>
</tr>
<tr>
<td>ssq::Table</td>
<td>table</td>
<td><code>toTable()</code></td>
</tr>
<tr>
<td>ssq::Array</td>
<td>array</td>
<td><code>toArray()</code></td>
</tr>
<tr>
<td>void*</td>
<td>userpointer</td>
<td><code>to&lt;void*&gt;()</code></td>
</tr>
<tr>
<td>any pointer to class <strong>not added to VM via addClass</strong></td>
<td>userpointer</td>
<td><code>to&lt;Class_Type*&gt;()</code></td>
</tr>
<tr>
<td>any reference (or copy) to class <strong>not added to VM via addClass</strong></td>
<td>userdata</td>
<td><code>to&lt;Class_Type&gt;()</code></td>
</tr>
<tr>
<td>pointer to class</td>
<td>instance</td>
<td><code>to&lt;Class_Type*&gt;()</code></td>
</tr>
<tr>
<td>reference or copy to class</td>
<td>instance</td>
<td><code>to&lt;Class_Type&gt;()</code></td>
</tr>
</tbody>
</table>
<p>Some types are divided into 32-bit and 64-bit groups. This is due to the fact how Squirrel handles integers.
On 64-bit compiler, the integer is stored as <code>long long</code>, on 32-bit compiler, it is stored as <code>long</code>. Therefore
in order to pass <code>long long</code> into squirrel on 32-bit compiler, it will be converted into userdata. We can&apos;t 
store 64-bit integer in 32-integer. Conversion to userdata is done to preserve the information. On 64-bit compiler
this is simply an integer. Floats are also stored as float on 32-bit compiler and double on 64-bit compiler.
<strong>Getting double from ssq::Object on 32-bit compiler will result in loss of information!</strong></p>
<p>Also, unsigned types are converted into signed types. For example, passing 0xFFFFFFFF (the max value of 
unsigned long) will be represented in squirrel as -1. However, when you try to get the -1 from Squirrel
back to C++ and you convert the function call result (from ssq::Object) to <code>to&lt;unsigned long&gt;()</code> it 
will be exactly the same as previously, the 0xFFFFFFFF. Information is always preserved, nothing is lost.
Therefore I highly suggest to use signed integers only.</p>
<p>Passing instance of classes as copy (or reference) will result in copy of the class
and the life of the instance will be handled by Squirrel. Passing any instance of class as a pointer 
will <strong>not</strong> create a copy and Squirrel will not handle the life of the instance.</p>
<p>If you create a C++ method where you create new instance of class and you return it as a pointer,
(example: <code>return new Foo(123, 456);</code>), the Squirrel will be able to access the methods and manipulate the 
object. However, it will never be released unless you do it manually from C++ side (by tracking your 
allocated objects).</p>
<p>If you return stack allocated object (example: <code>return Foo(123, 456);</code>) the Squirrel will create
a copy of the object and the life of the given object will be also handled by Squirrel.</p>
<p>For example, the following code will return copy of the instance inside of Squirrel:</p>
<pre><code class="lang-cpp">ssq::Function mySquirrelFunc = vm.findFunc(<span class="hljs-string">&quot;mySquirrelFunc&quot;</span>);
ssq::Object result = vm.call(mySquirrelFunc, vm, ...);
Foo copy = result.to&lt;Foo&gt;();
</code></pre>
<p>However the following will return pointer to the instance, no copy performed:</p>
<pre><code class="lang-cpp">ssq::Function mySquirrelFunc = vm.findFunc(<span class="hljs-string">&quot;mySquirrelFunc&quot;</span>);
ssq::Object result = vm.call(mySquirrelFunc, vm, ...);
Foo* copy = result.to&lt;Foo*&gt;();
</code></pre>
<p>Here is an example how to handle return value from function call:</p>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;simplesquirrel/simplesquirrel.hpp&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    ssq::<span class="hljs-function">VM <span class="hljs-title">vm</span><span class="hljs-params">(<span class="hljs-number">1024</span>, ssq::Libs::ALL)</span></span>;
    ssq::Script script = vm.compileSource(...);
    vm.run(script);

    ssq::Function mySquirrelFunc = vm.findFunc(<span class="hljs-string">&quot;mySquirrelFunc&quot;</span>);

    <span class="hljs-comment">// Get the result of the function call</span>
    ssq::Object result = vm.call(mySquirrelFunc, vm, <span class="hljs-number">10</span>, <span class="hljs-literal">true</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Hello World&quot;</span>));

    <span class="hljs-comment">// Check if the object is empty</span>
    result.isEmpty(); <span class="hljs-comment">// Returns true or false depending on what has been returned</span>

    <span class="hljs-comment">// Check if object is null</span>
    result.isNull(); <span class="hljs-comment">// True or false depending on what has been returned</span>

    <span class="hljs-comment">// Check if object is an integer</span>
    <span class="hljs-keyword">if</span> (result.getType() == ssq::Type::INTEGER) {
        <span class="hljs-comment">// Object is integer, we can convert it</span>
        <span class="hljs-keyword">int</span> myInt = result.toInt();
        <span class="hljs-comment">// or:</span>
        <span class="hljs-keyword">long</span> myInt2 = result.to&lt;<span class="hljs-keyword">long</span>&gt;();
    }

    <span class="hljs-comment">// Converting to something else than the object contains</span>
    <span class="hljs-comment">// results in ssq::TypeException thrown</span>
    <span class="hljs-keyword">try</span> {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str = result.toString();
    } <span class="hljs-keyword">catch</span> (ssq::TypeException&amp; e){
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 id="binding-c-function">Binding C++ function</h2>
<p>Binding C++ functions is simple as described below. The functions will be added 
into the root table and can be used across all scripts compiled within the VM.
The function arguments are deduced at compile time. No std::tuple, no std::any, 
just good old metaprogramming.</p>
<pre><code class="lang-cpp">#include &lt;simplesquirrel/simplesquirrel.hpp&gt;

std::string myCppFunc(int a, int b){
    return std::to_string(a + b);
}

int main(){
    ssq::VM vm(1024, ssq::Libs::ALL);

    // Bind global function
    vm.addFunc(&quot;myCppFunc&quot;, myCppFunc);

    // Bind global function via std::function
    std::function&lt;std::string(int, int)&gt; func = std::bind(
        myCppFunc, 
        std::placeholders::_1, 
        std::placeholders::_2
    );
    vm.addFunc(&quot;myCppFunc2&quot;, func);

    // Bind via lambda
    vm.addFunc(&quot;myCppFuncLambda, [](int a, int b) -&gt; std::string {
        return std::to_string(a + b);
    });

    return 0;
}
</code></pre>
<h2 id="call-squirrel-global-function">Call Squirrel global function</h2>
<p>First, you need to find the function you are looking for. This won&apos;t be done unless you
first compile <strong>and run</strong> the script. Squirrel is a dynamic language, therefore the functions
are evaulated at run time.</p>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;simplesquirrel/simplesquirrel.hpp&gt;</span></span>

<span class="hljs-built_in">std</span>::<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">myCppFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::to_string(a + b);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    ssq::<span class="hljs-function">VM <span class="hljs-title">vm</span><span class="hljs-params">(<span class="hljs-number">1024</span>, ssq::Libs::ALL)</span></span>;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> source = 
    <span class="hljs-string">&quot;function mySquirrelFunc(a, b){\n&quot;</span>
    <span class="hljs-string">&quot;    return a + b;\n&quot;</span>
    <span class="hljs-string">&quot;}\n&quot;</span>;

    ssq::Script script = vm.compileSource(source.c_str());
    vm.run(script);

    <span class="hljs-comment">// Now the mySquirrelFunc is ready for us, let&apos;s</span>
    <span class="hljs-comment">// find it from VM</span>
    ssq::Function mySquirrelFunc = vm.findFunc(<span class="hljs-string">&quot;mySquirrelFunc&quot;</span>);

    <span class="hljs-comment">// We can get the number of parameters required via:</span>
    <span class="hljs-comment">// mySquirrelFunc.getNumOfParams()</span>

    <span class="hljs-comment">// Call the function</span>
    <span class="hljs-comment">// The second parameter is the &quot;this&quot; pointer!</span>
    <span class="hljs-comment">// If the function was part of class (member function) then</span>
    <span class="hljs-comment">// the second parameter needs to be an instance object.</span>
    <span class="hljs-comment">// Since the mySquirrelFunc is global, we will pass the</span>
    <span class="hljs-comment">// root table -&gt; the VM instance.</span>
    ssq::Object result = vm.call(mySquirrelFunc, vm, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>);

    <span class="hljs-comment">// We have the result and we can check its type via:</span>
    <span class="hljs-comment">// result.getType() which returns ssq::Type enum</span>
    <span class="hljs-comment">// Or get the type as const char*</span>
    <span class="hljs-comment">// result.getTypeStr()</span>

    <span class="hljs-comment">// Convert the result to integer</span>
    <span class="hljs-keyword">int</span> myInt = result.toInt();

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;mySquirrelFunc returned: &quot;</span> &lt;&lt; myInt &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 id="bind-c-class">Bind C++ class</h2>
<p>Binding of classes is done via <code>ssq::VM::addClass(...)</code>. You have to expose your class to VM. Otherwise 
any of your classes will be passed around in squirrel as user data and not as an instance. </p>
<p>You don&apos;t need to expose your class if you do not wish to use it in Squirrel as an instance. Any
classes or any types that are not integers, strings, booleans, will be automatically converted into 
Squirrel user data. User data can be moved around, pushed to Squirrel or returned from. User data 
cannot be manipulated, has no methods, and is created via copy. For example, you won&apos;t be able 
to use <code>std::unique_ptr</code> as userdata because it does not allow a copy.</p>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;simplesquirrel/simplesquirrel.hpp&gt;</span></span>

<span class="hljs-keyword">class</span> Foo {
<span class="hljs-keyword">public</span>:
    Foo(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; msg):msg(msg) {
    }

    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">getMsg</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> msg;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setMsg</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; msg)</span> </span>{
        <span class="hljs-keyword">this</span>-&gt;msg = msg;
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">expose</span><span class="hljs-params">(ssq::VM&amp; vm)</span> </span>{
        ssq::Class cls = vm.addClass(<span class="hljs-string">&quot;Foo&quot;</span>, ssq::Class::Ctor&lt;Foo(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>)&gt;());

        <span class="hljs-comment">// You can also use lambdas (or std::function) to define constructor</span>
        <span class="hljs-comment">// The function has to return pointer to the new instance</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// vm.addClass(&quot;Foo&quot;, [](std::string msg) -&gt; Foo* {</span>
        <span class="hljs-comment">//     return new Foo(msg);</span>
        <span class="hljs-comment">// });</span>

        cls.addFunc(<span class="hljs-string">&quot;getMsg&quot;</span>, &amp;Foo::getMsg);
        cls.addFunc(<span class="hljs-string">&quot;setMsg&quot;</span>, &amp;Foo::setMsg);

        cls.addVar(<span class="hljs-string">&quot;msg&quot;</span>, &amp;Foo::msg);
    }

    <span class="hljs-comment">// For the purpose of this example we will treat msg as public</span>
    <span class="hljs-comment">// so we can expose it via cls.addVar</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> msg;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    ssq::<span class="hljs-function">VM <span class="hljs-title">vm</span><span class="hljs-params">(<span class="hljs-number">1024</span>, ssq::Libs::ALL)</span></span>;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> source = 
    <span class="hljs-string">&quot;// Create instance\n&quot;</span>
    <span class="hljs-string">&quot;local foo = Foo(\&quot;Hello World\&quot;);\n&quot;</span>
    <span class="hljs-string">&quot;\n&quot;</span>
    <span class="hljs-string">&quot;// Call C++ methods\n&quot;</span>
    <span class="hljs-string">&quot;print(\&quot;Foo has message: \&quot; + foo.getMessage());\n&quot;</span>
    <span class="hljs-string">&quot;foo.setMessage(\&quot;Something else\&quot;);\n&quot;</span>
    <span class="hljs-string">&quot;\n&quot;</span>
    <span class="hljs-string">&quot;// Access the variable directly\n&quot;</span>
    <span class="hljs-string">&quot;print(\&quot;Foo now has: \&quot; + foo.msg);\n&quot;</span>
    <span class="hljs-string">&quot;\n&quot;</span>;

    ssq::Script script = vm.compileSource(source.c_str());
    Foo::expose(vm); <span class="hljs-comment">// Bind the class to this VM</span>
    vm.run(script);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 id="class-const-method-ambiguity">Class const method ambiguity</h2>
<p>Sometimes, it is possible that your class has for example two methods:</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">class</span> Foo {
    ...
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">getMessage</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">getMessage</span><span class="hljs-params">()</span></span>;

    <span class="hljs-keyword">static</span> ssq::<span class="hljs-function">Class <span class="hljs-title">expose</span><span class="hljs-params">(ssq::VM&amp; vm)</span></span>;
};
</code></pre>
<p>One gets to be used when you have constant reference (or pointer) and the second one
when you have non-constant reference. Binding these methods to Squirrel class can
cause compiler ambiguity error. You can solve the problem by explicitly defining the
template when binding those functions, for example:</p>
<pre><code>static void Foo::expose(ssq::VM&amp; vm) {
    ssq::Class cls = vm.addClass(&quot;Foo&quot;, ssq::Class::Ctor&lt;Foo(.....)&gt;());

    // Explicitly define return type to &quot;const std::string&amp;&quot; in order
    // for the compiler to know which overloaded method to use.
    cls.addFunc&lt;const std::string&amp;&gt;(&quot;getMessage&quot;, &amp;Foo::getMessage);
}
</code></pre><h2 id="find-squirrel-class-and-create-instance">Find Squirrel class and create instance</h2>
<p>Finding classes and creating instances is easy as the following code below. 
It is self explanatory.</p>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;simplesquirrel/simplesquirrel.hpp&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    ssq::<span class="hljs-function">VM <span class="hljs-title">vm</span><span class="hljs-params">(<span class="hljs-number">1024</span>, ssq::Libs::ALL)</span></span>;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> source = 
    <span class="hljs-string">&quot;class Foo {\n&quot;</span>
    <span class="hljs-string">&quot;    constructor(msg) {\n&quot;</span>
    <span class="hljs-string">&quot;        value = msg;\n&quot;</span>
    <span class="hljs-string">&quot;    }\n&quot;</span>
    <span class="hljs-string">&quot;\n&quot;</span>
    <span class="hljs-string">&quot;    function setMsg(msg) {\n&quot;</span>
    <span class="hljs-string">&quot;        msg = value;\n&quot;</span>
    <span class="hljs-string">&quot;    }\n&quot;</span>
    <span class="hljs-string">&quot;\n&quot;</span>
    <span class="hljs-string">&quot;    function getMsg() {\n&quot;</span>
    <span class="hljs-string">&quot;        return msg;\n&quot;</span>
    <span class="hljs-string">&quot;    }\n&quot;</span>
    <span class="hljs-string">&quot;\n&quot;</span>
    <span class="hljs-string">&quot;    value = null;\n&quot;</span>
    <span class="hljs-string">&quot;}\n&quot;</span>;

    ssq::Script script = vm.compileSource(source.c_str());
    vm.run(script);

    <span class="hljs-comment">// Find class</span>
    ssq::Class cls = vm.findClass(<span class="hljs-string">&quot;Foo&quot;</span>);

    <span class="hljs-comment">// Create instance of it.</span>
    <span class="hljs-comment">// The life of the object is determined by Squirrel.</span>
    <span class="hljs-comment">// You don&apos;t need to release the object yourself.</span>
    ssq::Instance clsInstance = vm.newInstance(cls, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>));

    <span class="hljs-comment">// Find class methods</span>
    ssq::Function funcSetMsg = cls.findFunc(<span class="hljs-string">&quot;setMsg&quot;</span>);
    ssq::Function funcGetMsg = cls.findFunc(<span class="hljs-string">&quot;getMsg&quot;</span>);

    <span class="hljs-comment">// Call method, set new message</span>
    vm.callFunc(funcSetMsg, clsInstance, <span class="hljs-string">&quot;Banana&quot;</span>);

    <span class="hljs-comment">// Get the message back</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> result = vm.callFunc(funcGetMsg, clsInstance).toString();

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Foo now contains: &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 id="manipulate-squirrel-array">Manipulate Squirrel array</h2>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;simplesquirrel/simplesquirrel.hpp&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    ssq::<span class="hljs-function">VM <span class="hljs-title">vm</span><span class="hljs-params">(<span class="hljs-number">1024</span>, ssq::Libs::ALL)</span></span>;
    ssq::Script script = vm.compileSource(...);
    vm.run(script);

    <span class="hljs-comment">// Create new array</span>
    ssq::Array arr = vm.newArray();

    <span class="hljs-comment">// To get the size of the array use: arr.size() </span>

    <span class="hljs-comment">// Push at the back </span>
    <span class="hljs-comment">// You can push any object you want. No limits.</span>
    arr.push(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Hello World&quot;</span>));
    arr.push(<span class="hljs-literal">true</span>);
    arr.push(<span class="hljs-number">123</span>);

    <span class="hljs-comment">// You can retrieve individual indexes via:</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> first = arr.get&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">0</span>);

    <span class="hljs-comment">// If you want raw object (ssq::Object) do it as:</span>
    ssq::Object firstRaw = arr.get&lt;ssq::Object&gt;(<span class="hljs-number">0</span>);

    <span class="hljs-comment">// Use pop to release last element</span>
    <span class="hljs-keyword">int</span> arr.popAndGet&lt;<span class="hljs-keyword">int</span>&gt;();

    <span class="hljs-comment">// If you do not want to get the last element while removing it</span>
    <span class="hljs-comment">// use the following:</span>
    arr.pop(); <span class="hljs-comment">// Returns nothing</span>

    <span class="hljs-comment">// Then, simply pass it into any squirrel function as any other value</span>
    ssq::Function mySquirrelFunc = vm.findFunc(<span class="hljs-string">&quot;mySquirrelFunc&quot;</span>);
    vm.call(mySquirrelFunc, vm, arr);

    <span class="hljs-comment">// If you want to retrieve array from squirrel function,</span>
    <span class="hljs-comment">// you can do it simply by converting the return value to array:</span>
    ssq::Array result = vm.call(..., vm).toArray();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 id="manipulate-squirrel-table">Manipulate Squirrel table</h2>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;simplesquirrel/simplesquirrel.hpp&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    ssq::<span class="hljs-function">VM <span class="hljs-title">vm</span><span class="hljs-params">(<span class="hljs-number">1024</span>, ssq::Libs::ALL)</span></span>;
    ssq::Script script = vm.compileSource(...);
    vm.run(script);

    <span class="hljs-comment">// Create new table</span>
    ssq::Table table = vm.newTable();

    <span class="hljs-comment">// To get the size of the table use: table.size() </span>

    <span class="hljs-comment">// Add new indexes via key-value pairs</span>
    <span class="hljs-comment">// You can add any object you want. No limits.</span>
    table.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;myString&quot;</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Hello World&quot;</span>));
    table.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;myBool&quot;</span>, <span class="hljs-literal">true</span>);
    table.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;myInt&quot;</span>, <span class="hljs-number">123</span>);

    <span class="hljs-comment">// You can retrieve individual indexes via:</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> first = table.get&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;myString&quot;</span>);

    <span class="hljs-comment">// If you want raw object (ssq::Object) do it as:</span>
    ssq::Object firstRaw = table.get&lt;ssq::Object&gt;(<span class="hljs-string">&quot;myString&quot;</span>);

    <span class="hljs-comment">// Then, simply pass it into any squirrel function as any other value</span>
    ssq::Function mySquirrelFunc = vm.findFunc(<span class="hljs-string">&quot;mySquirrelFunc&quot;</span>);
    vm.call(mySquirrelFunc, vm, table);

    <span class="hljs-comment">// If you want to retrieve table from squirrel function,</span>
    <span class="hljs-comment">// you can do it simply by converting the return value to table:</span>
    ssq::Table result = vm.call(..., vm).toTable();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 id="weak-references-and-callbacks">Weak references and callbacks</h2>
<p>There is a problem when you want to register a callback into C++ side. For example,
you have a GUI widget that has onClick method. But, the onClick method accepts <code>std::function</code>
and not Squirrel objects. So, you will probably try to do the following:</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// This will cause undefined behavior! Most likely SEGFAULT! See another example below...</span>
fooClass.addFunc(<span class="hljs-string">&quot;setOnClickCallback&quot;</span>, [](Foo* self, ssq::Function func, ssq::Instance inst) -&gt; <span class="hljs-keyword">void</span> {
    <span class="hljs-comment">// Using ssq::Instance here is OK!</span>
    doSomethingElse(inst);

    self.setOnClick([=](SomeEventData data) {
        <span class="hljs-comment">// Using ssq::Instance in here nested lambda with [=] capture is bad!</span>
        vm.callFunc(func, inst, data);
    });
});

<span class="hljs-comment">// On program exit...</span>
SEGFAULT
</code></pre>
<p>And then inside of Squirrel:</p>
<pre><code>class Bar extends Foo {
    ...
}

local bar = Bar(...);
baz.setOnClickCallback(function(data){
    print(&quot;I got some data!&quot;);
}, bar);
</code></pre><p>Why is this bad? Because the inner lambda captures the instance, it will cause to extend the
life of Foo object inside of Squirrel. When you try to destroy your VM, it will most likely cause
to crash program. Squirrel tracks objects by reference so that when reference counter goes to zero,
the object is deleted. With the example above the ssq::Instance object will live inside of the lambda
capture, extending the life of the instance. The reference counter will always be +1. This problem
only happens when you use lambda capture inside of lambda as above. 
<strong>How to solve this? Use weak reference!</strong> </p>
<pre><code class="lang-cpp"><span class="hljs-comment">// This will NOT cause any problems</span>
fooClass.addFunc(<span class="hljs-string">&quot;setOnClickCallback&quot;</span>, [](Foo* self, ssq::Function func, SqWeakRef ref) -&gt; <span class="hljs-keyword">void</span> {
    self.setOnClick([=](SomeEventData data) {
        vm.callFunc(func, ref, data);
    });
});

<span class="hljs-comment">// On program exit...</span>
<span class="hljs-comment">// All ok... No SEGFAULT</span>
</code></pre>
<p>With the weak reference, the life of the instance won&apos;t be extended. The weak reference does
not increament the reference counter at all. It does not matter for how long the lambda captured
variable (the <code>ref</code> parameter) will live, it won&apos;t affect us at all. </p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                
                <a href="docs/ssq.html" class="navigation navigation-next navigation-unique" aria-label="Next page: ssq">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Introduction","level":"1.1","depth":1,"next":{"title":"ssq","level":"1.2","depth":1,"path":"docs/ssq.md","ref":"docs/ssq.md","articles":[{"title":"Array","level":"1.2.1","depth":2,"path":"docs/ssq_Array.md","ref":"docs/ssq_Array.md","articles":[]},{"title":"Class","level":"1.2.2","depth":2,"path":"docs/ssq_Class.md","ref":"docs/ssq_Class.md","articles":[{"title":"Ctor","level":"1.2.2.1","depth":3,"path":"docs/ssq_Class_Ctor.md","ref":"docs/ssq_Class_Ctor.md","articles":[]},{"title":"Ctor< T(Args...)>","level":"1.2.2.2","depth":3,"path":"docs/ssq_Class_Ctor__T_Args_____.md","ref":"docs/ssq_Class_Ctor__T_Args_____.md","articles":[]}]},{"title":"CompileException","level":"1.2.3","depth":2,"path":"docs/ssq_CompileException.md","ref":"docs/ssq_CompileException.md","articles":[]},{"title":"Enum","level":"1.2.4","depth":2,"path":"docs/ssq_Enum.md","ref":"docs/ssq_Enum.md","articles":[]},{"title":"Exception","level":"1.2.5","depth":2,"path":"docs/ssq_Exception.md","ref":"docs/ssq_Exception.md","articles":[]},{"title":"Function","level":"1.2.6","depth":2,"path":"docs/ssq_Function.md","ref":"docs/ssq_Function.md","articles":[]},{"title":"Instance","level":"1.2.7","depth":2,"path":"docs/ssq_Instance.md","ref":"docs/ssq_Instance.md","articles":[]},{"title":"Libs","level":"1.2.8","depth":2,"path":"docs/ssq_Libs.md","ref":"docs/ssq_Libs.md","articles":[]},{"title":"NotFoundException","level":"1.2.9","depth":2,"path":"docs/ssq_NotFoundException.md","ref":"docs/ssq_NotFoundException.md","articles":[]},{"title":"Object","level":"1.2.10","depth":2,"path":"docs/ssq_Object.md","ref":"docs/ssq_Object.md","articles":[]},{"title":"RuntimeException","level":"1.2.11","depth":2,"path":"docs/ssq_RuntimeException.md","ref":"docs/ssq_RuntimeException.md","articles":[]},{"title":"Script","level":"1.2.12","depth":2,"path":"docs/ssq_Script.md","ref":"docs/ssq_Script.md","articles":[]},{"title":"SqWeakRef","level":"1.2.13","depth":2,"path":"docs/ssq_SqWeakRef.md","ref":"docs/ssq_SqWeakRef.md","articles":[]},{"title":"Table","level":"1.2.14","depth":2,"path":"docs/ssq_Table.md","ref":"docs/ssq_Table.md","articles":[]},{"title":"TypeException","level":"1.2.15","depth":2,"path":"docs/ssq_TypeException.md","ref":"docs/ssq_TypeException.md","articles":[]},{"title":"VM","level":"1.2.16","depth":2,"path":"docs/ssq_VM.md","ref":"docs/ssq_VM.md","articles":[]}]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["page-toc","highlight"],"pluginsConfig":{"page-toc":{"position":"before-first","selector":".markdown-section h1, .markdown-section h2"},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"README.md","mtime":"2018-02-04T19:53:36.950Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-02-04T19:54:13.865Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-page-toc/anchor-3.1.1.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-page-toc/page-toc.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

